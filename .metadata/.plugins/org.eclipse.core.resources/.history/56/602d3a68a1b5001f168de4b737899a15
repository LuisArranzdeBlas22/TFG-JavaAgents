package com.luis.tfg.security;

import org.junit.jupiter.api.Test;

import static org.junit.jupiter.api.Assertions.*;

import java.util.List;
import java.util.Map;

public class MethodOrderAgentTest {

    @Test
    public void testValidOrder() {
        TestClass instance = new TestClass("id1");
        ExecutionOrderRegistry.register(instance, "(start process end)");

        StateMachine sm = ExecutionOrderRegistry.getStateMachine(instance);
        assertNotNull(sm, "StateMachine should not be null");

        assertTrue(sm.validateTransition("start"), "Transition to 'start' should be valid");
        assertTrue(sm.validateTransition("process"), "Transition to 'process' should be valid");
        assertTrue(sm.validateTransition("end"), "Transition to 'end' should be valid");

        assertTrue(sm.isInFinalState(), "StateMachine should be in a final state");
    }

    @Test
    public void testNotEndingInFinalState() {
        System.out.println("[TEST] Starting testNotEndingInFinalState");

        TestClass instance = new TestClass("id2");
        ExecutionOrderRegistry.register(instance, "(start process end)");

        StateMachine sm = ExecutionOrderRegistry.getStateMachine(instance);
        assertNotNull(sm, "StateMachine should not be null");

        try {
            assertTrue(sm.validateTransition("start"));
            assertTrue(sm.validateTransition("process"));
            assertFalse(sm.isInFinalState(), "StateMachine should not be in a final state");
        } catch (IllegalStateException e) {
            fail("Unexpected IllegalStateException: " + e.getMessage());
        }

        System.out.println("[TEST] Finished testNotEndingInFinalState");
    }

    @Test
    public void testInvalidOrder() {
        System.out.println("[TEST] Starting testInvalidOrder");

        TestClass instance = new TestClass("id3");
        ExecutionOrderRegistry.register(instance, "(start process end)");

        StateMachine sm = ExecutionOrderRegistry.getStateMachine(instance);
        assertNotNull(sm, "StateMachine should not be null");

        try {
            sm.validateTransition("start");
            sm.validateTransition("end"); // Invalid transition
            fail("Expected an IllegalStateException due to invalid transition");
        } catch (IllegalStateException e) {
            assertTrue(e.getMessage().contains("Invalid transition from start to end"),
                    "Expected detailed invalid transition exception");
        }

        System.out.println("[TEST] Finished testInvalidOrder");
    }

    @Test
    public void testStateMachineNotFound() {
        System.out.println("[TEST] Starting testStateMachineNotFound");

        TestClass instance = new TestClass("id4");
        StateMachine sm = ExecutionOrderRegistry.getStateMachine(instance);
        assertNull(sm, "StateMachine should not be found for unregistered instance");

        System.out.println("[TEST] Finished testStateMachineNotFound");
    }

    @Test
    public void testFlexibleSequence() {
        System.out.println("[TEST] Starting testFlexibleSequence");

        TestClass instance = new TestClass("id5");
        ExecutionOrderRegistry.register(instance, "(start .* end)");

        StateMachine sm = ExecutionOrderRegistry.getStateMachine(instance);
        assertNotNull(sm, "StateMachine should not be null");

        try {
            assertTrue(sm.validateTransition("start"));
            assertTrue(sm.validateTransition("middle"));
            assertTrue(sm.validateTransition("end"));

            assertTrue(sm.isInFinalState(), "StateMachine should end in a final state");
        } catch (IllegalStateException e) {
            fail("Unexpected IllegalStateException: " + e.getMessage());
        }

        System.out.println("[TEST] Finished testFlexibleSequence");
    }

    @Test
    public void testAndCondition() {
        TestClass instance = new TestClass("id6");
        ExecutionOrderRegistry.register(instance, "(start & process) -> end");

        StateMachine sm = ExecutionOrderRegistry.getStateMachine(instance);
        assertNotNull(sm);

        assertTrue(sm.validateTransition("start"), "Transition to 'start' should be valid");
        assertTrue(sm.validateTransition("process"), "Transition to 'process' should be valid");
        assertTrue(sm.validateTransition("end"), "Transition to 'end' should be valid");

        assertTrue(sm.isInFinalState(), "StateMachine should be in a final state");
    }
    
    @Test
    public void testAndCondition2() {
        TestClass instance = new TestClass("id12");
        ExecutionOrderRegistry.register(instance, "(process & start) -> end");

        StateMachine sm = ExecutionOrderRegistry.getStateMachine(instance);
        assertNotNull(sm);

        assertTrue(sm.validateTransition("start"), "Transition to 'start' should be valid");
        assertTrue(sm.validateTransition("process"), "Transition to 'process' should be valid");
        assertTrue(sm.validateTransition("end"), "Transition to 'end' should be valid");

        assertTrue(sm.isInFinalState(), "StateMachine should be in a final state");
    }


    @Test
    public void testOrCondition() {
        System.out.println("[TEST] Starting testOrCondition");

        TestClass instance = new TestClass("id7");
        ExecutionOrderRegistry.register(instance, "(start | process) -> end");

        StateMachine sm = ExecutionOrderRegistry.getStateMachine(instance);
        assertNotNull(sm, "StateMachine should not be null");

        try {
            assertTrue(sm.validateTransition("start"));
            assertTrue(sm.validateTransition("process"));
            assertTrue(sm.validateTransition("end"));

            assertTrue(sm.isInFinalState(), "StateMachine should end in a final state");
        } catch (IllegalStateException e) {
            fail("Unexpected IllegalStateException: " + e.getMessage());
        }

        System.out.println("[TEST] Finished testOrCondition");
    }
    
    @Test
    public void testOrCondition2() {
        System.out.println("[TEST] Starting testOrCondition");

        TestClass instance = new TestClass("id72");
        ExecutionOrderRegistry.register(instance, "(process | start) -> end");

        StateMachine sm = ExecutionOrderRegistry.getStateMachine(instance);
        assertNotNull(sm, "StateMachine should not be null");

        try {
            assertTrue(sm.validateTransition("process"));
            assertTrue(sm.validateTransition("end"));

            assertTrue(sm.isInFinalState(), "StateMachine should end in a final state");
        } catch (IllegalStateException e) {
            fail("Unexpected IllegalStateException: " + e.getMessage());
        }

        System.out.println("[TEST] Finished testOrCondition");
    }

    @Test
    public void testRepetition() {
        TestClass instance = new TestClass("id8");
        ExecutionOrderRegistry.register(instance, "(repeat){2} -> end");

        StateMachine sm = ExecutionOrderRegistry.getStateMachine(instance);
        assertNotNull(sm);

        assertTrue(sm.validateTransition("repeat"), "First repeat should be valid");
        assertTrue(sm.validateTransition("repeat"), "Second repeat should be valid");
        assertTrue(sm.validateTransition("end"), "Transition to end should be valid");

        assertTrue(sm.isInFinalState(), "StateMachine should be in a final state");
    }

    

    @Test
    public void testInvalidRepetition() {
        System.out.println("[TEST] Starting testInvalidRepetition");

        TestClass instance = new TestClass("id10");
        ExecutionOrderRegistry.register(instance, "(repeat){2} -> end");

        StateMachine sm = ExecutionOrderRegistry.getStateMachine(instance);
        assertNotNull(sm, "StateMachine should not be null");

        try {
            sm.validateTransition("repeat");
            sm.validateTransition("end");
            fail("Expected an IllegalStateException due to invalid transition");
        } catch (IllegalStateException e) {
            assertTrue(e.getMessage().contains("Invalid transition"),
                    "Expected detailed invalid transition exception");
        }

        System.out.println("[TEST] Finished testInvalidRepetition");
    }
    
    @Test
    public void testGetTransitions() {
        System.out.println("[TEST] Starting testGetTransitions");

        TestClass instance = new TestClass("id21");
        ExecutionOrderRegistry.register(instance, "(start process end -> FINAL)");

        StateMachine sm = ExecutionOrderRegistry.getStateMachine(instance);
        assertNotNull(sm, "StateMachine should not be null");

        Map<String, List<String>> transitions = sm.getTransitions();
        
        // Verificar que hay 4 estados con transiciones ahora (INITIAL incluido)
        assertEquals(4, transitions.size(), "StateMachine should have 4 states with transitions (including INITIAL)");

        // Validar que INITIAL tiene transición a "start"
        assertTrue(transitions.containsKey("INITIAL"), "StateMachine should contain INITIAL state");
        assertTrue(transitions.get("INITIAL").contains("start"), "INITIAL state should transition to start");

        // Validar las transiciones del flujo principal
        assertTrue(transitions.containsKey("start"), "StateMachine should contain start state");
        assertTrue(transitions.get("start").contains("process"), "start state should transition to process");

        assertTrue(transitions.containsKey("process"), "StateMachine should contain process state");
        assertTrue(transitions.get("process").contains("end"), "process state should transition to end");

        assertTrue(transitions.containsKey("end"), "StateMachine should contain end state");
        assertTrue(transitions.get("end").contains("FINAL"), "end state should transition to FINAL");

        System.out.println("[TEST] Finished testGetTransitions");
    }
    
    @Test
    public void testNoRedundantTransitionsFromInitial() {
        TestClass instance = new TestClass("id22");
        ExecutionOrderRegistry.register(instance, "(start process end)");

        StateMachine sm = ExecutionOrderRegistry.getStateMachine(instance);
        assertNotNull(sm, "StateMachine should not be null");

        List<String> initialTransitions = sm.getTransitions().get("INITIAL");
        assertNotNull(initialTransitions, "Transitions from INITIAL should not be null");
        assertEquals(1, initialTransitions.size(), "INITIAL should only transition to 'start'");
        assertTrue(initialTransitions.contains("start"), "INITIAL should transition only to 'start'");
    }
    
    @Test
    public void testInvalidRepeatedTransition() {
        TestClass instance = new TestClass("id23");
        ExecutionOrderRegistry.register(instance, "(start process end)");

        StateMachine sm = ExecutionOrderRegistry.getStateMachine(instance);
        assertNotNull(sm, "StateMachine should not be null");

        try {
            sm.validateTransition("start");
            sm.validateTransition("start"); // Repeated transition
            fail("Expected an IllegalStateException due to repeated transition");
        } catch (IllegalStateException e) {
            assertTrue(e.getMessage().contains("Invalid transition"), 
                "Expected an invalid transition exception for repeated state");
        }
    }
    
    @Test
    public void testMultipleOrTransitions() {
        TestClass instance = new TestClass("id24");
        ExecutionOrderRegistry.register(instance, "(start | process) -> end -> FINAL");

        StateMachine sm = ExecutionOrderRegistry.getStateMachine(instance);
        assertNotNull(sm, "StateMachine should not be null");

        // Realizar las transiciones esperadas
        sm.validateTransition("start"); // Transición válida a "start"
        sm.validateTransition("end");   // Transición válida a "end"

        // Verificar que estamos en un estado final declarado (antes de FINAL)
        assertTrue(sm.isInFinalState(), "StateMachine should consider 'end' as a final state with transition to 'FINAL'");

        // Realizar una transición explícita al estado FINAL
        sm.validateTransition("FINAL"); // Transición válida a "FINAL"

        // Verificar que el estado actual es FINAL
        assertEquals("FINAL", sm.getCurrentState().getId(), "Current state should be 'FINAL'");

        // Intentar otra transición desde FINAL debe fallar
        try {
            sm.validateTransition("start");
            fail("Expected IllegalStateException for transition from final state");
        } catch (IllegalStateException e) {
            assertTrue(e.getMessage().contains("Cannot transition from final state"),
                    "Expected exception for transition from final state");
        }
    }

    
    @Test
    public void testAndOrCombination() {
        // Prueba la rama del operador AND
        TestClass instanceAnd = new TestClass("id55-and"); // Identificador único
        ExecutionOrderRegistry.register(instanceAnd, "((start & process) | middle) -> end -> FINAL");

        StateMachine smAnd = ExecutionOrderRegistry.getStateMachine(instanceAnd);
        assertNotNull(smAnd, "StateMachine for AND branch should not be null");

        // Validar transiciones en la rama AND
        assertTrue(smAnd.validateTransition("start"), "Transition to 'start' should be valid");
        assertTrue(smAnd.validateTransition("process"), "Transition to 'process' should be valid");
        assertTrue(smAnd.validateTransition("end"), "Transition to 'end' should be valid");

        // Prueba la rama del operador OR
        TestClass instanceOr = new TestClass("id55-or"); // Identificador único
        ExecutionOrderRegistry.register(instanceOr, "((start & process) | middle) -> end -> FINAL");

        StateMachine smOr = ExecutionOrderRegistry.getStateMachine(instanceOr);
        assertNotNull(smOr, "StateMachine for OR branch should not be null");

        // Validar transiciones en la rama OR
        assertTrue(smOr.validateTransition("middle"), "Transition to 'middle' should be valid");
        assertTrue(smOr.validateTransition("end"), "Transition to 'end' should be valid after 'middle'");
    }

    
    @Test
    public void testNoTransitionsFromFinalState() {
        TestClass instance = new TestClass("id26");
        ExecutionOrderRegistry.register(instance, "(start process end) -> FINAL");

        StateMachine sm = ExecutionOrderRegistry.getStateMachine(instance);
        assertNotNull(sm, "StateMachine should not be null");

        sm.validateTransition("start");
        sm.validateTransition("process");
        sm.validateTransition("end");

        // Validar que al llegar a 'end' estamos en un estado final declarado
        assertTrue(sm.isInFinalState(), "StateMachine should be in a final state");
        assertEquals("end", sm.getCurrentState().getId(), "Current state should be the declared final state ('end')");

        // Probar transición explícita a FINAL
        sm.validateTransition("FINAL");

        // Validar que el estado actual es FINAL
        assertEquals("FINAL", sm.getCurrentState().getId(), "Current state should be FINAL");

        try {
            sm.validateTransition("process");
            fail("Expected an IllegalStateException for transition from final state");
        } catch (IllegalStateException e) {
            assertTrue(e.getMessage().contains("Cannot transition from final state"),
                "Expected exception for transition from final state");
        }
    }

    
    @Test
    public void testWildcardTransitions() {
        TestClass instance = new TestClass("id337");
        ExecutionOrderRegistry.register(instance, "(start .* end)");

        StateMachine sm = ExecutionOrderRegistry.getStateMachine(instance);
        assertNotNull(sm, "StateMachine should not be null");

        assertTrue(sm.validateTransition("start"), "Transition to 'start' should be valid");
        assertTrue(sm.validateTransition("intermediate1"), "Wildcard transition should be valid");
        assertTrue(sm.validateTransition("intermediate2"), "Wildcard transition should be valid");
        assertTrue(sm.validateTransition("end"), "Transition to 'end' should be valid");

        assertTrue(sm.isInFinalState(), "StateMachine should end in a final state");
    }

    
    @Test
    public void testMultipleStateMachines() {
        TestClass instance1 = new TestClass("id28");
        TestClass instance2 = new TestClass("id29");

        ExecutionOrderRegistry.register(instance1, "(start process end)");
        ExecutionOrderRegistry.register(instance2, "(init action done)");

        StateMachine sm1 = ExecutionOrderRegistry.getStateMachine(instance1);
        StateMachine sm2 = ExecutionOrderRegistry.getStateMachine(instance2);

        assertNotNull(sm1, "StateMachine for instance1 should not be null");
        assertNotNull(sm2, "StateMachine for instance2 should not be null");

        // Verificar transiciones en sm1
        assertTrue(sm1.validateTransition("start"));
        assertTrue(sm1.validateTransition("process"));
        assertTrue(sm1.validateTransition("end"));
        assertTrue(sm1.isInFinalState(), "StateMachine for instance1 should end in a final state");

        // Verificar transiciones en sm2
        assertTrue(sm2.validateTransition("init"));
        assertTrue(sm2.validateTransition("action"));
        assertTrue(sm2.validateTransition("done"));
        assertTrue(sm2.isInFinalState(), "StateMachine for instance2 should end in a final state");
    }
    
    @Test
    public void testWildcardTransitions2() {
        System.out.println("[TEST] Starting testWildcardTransitions");

        TestClass instance = new TestClass("id31");
        ExecutionOrderRegistry.register(instance, "(start .* middle .* end)");

        StateMachine sm = ExecutionOrderRegistry.getStateMachine(instance);
        assertNotNull(sm, "StateMachine should not be null");

        try {
            assertTrue(sm.validateTransition("start"), "Start transition should be valid");
            assertTrue(sm.validateTransition("step1"), "Wildcard step1 should be valid");
            assertTrue(sm.validateTransition("middle"), "Middle transition should be valid");
            assertTrue(sm.validateTransition("step2"), "Wildcard step2 should be valid");
            assertTrue(sm.validateTransition("end"), "End transition should be valid");

            assertTrue(sm.isInFinalState(), "StateMachine should be in a final state");
        } catch (IllegalStateException e) {
            fail("Unexpected IllegalStateException: " + e.getMessage());
        }

        System.out.println("[TEST] Finished testWildcardTransitions");
    }
    
    @Test
    public void testFlexibleSequence2() {
        System.out.println("[TEST] Starting testFlexibleSequence");

        TestClass instance = new TestClass("id27");
        ExecutionOrderRegistry.register(instance, "(start .* end)");

        StateMachine sm = ExecutionOrderRegistry.getStateMachine(instance);
        assertNotNull(sm, "StateMachine should not be null");

        try {
            assertTrue(sm.validateTransition("start"), "Start transition should be valid");
            assertTrue(sm.validateTransition("step1"), "Wildcard step1 should be valid");
            assertTrue(sm.validateTransition("step2"), "Wildcard step2 should be valid");
            assertTrue(sm.validateTransition("end"), "End transition should be valid");

            assertTrue(sm.isInFinalState(), "StateMachine should be in a final state");
        } catch (IllegalStateException e) {
            fail("Unexpected IllegalStateException: " + e.getMessage());
        }

        System.out.println("[TEST] Finished testFlexibleSequence");
    }
    
    @Test
    public void testOrAndCombination() {
        System.out.println("[TEST] Starting testOrAndCombination");

        // Configuración de la máquina de estados
        TestClass instance = new TestClass("id-or-and");
        ExecutionOrderRegistry.register(instance, "((start | process) & end) -> FINAL");

        StateMachine sm = ExecutionOrderRegistry.getStateMachine(instance);
        assertNotNull(sm, "StateMachine should not be null");

        try {
            // Validar transición OR (start)
            assertTrue(sm.validateTransition("start"), "Transition to 'start' should be valid");

            // Validar transición AND (end después de start)
            assertTrue(sm.validateTransition("end"), "Transition to 'end' should be valid after 'start'");

            // Transición explícita a FINAL
            assertTrue(sm.validateTransition("FINAL"), "Transition to 'FINAL' should be valid");

            // Validar estado final
            assertTrue(sm.isInFinalState(), "StateMachine should be in a final state");

            // Intentar una transición adicional desde FINAL
            try {
                sm.validateTransition("start");
                fail("Expected IllegalStateException for transition from final state");
            } catch (IllegalStateException e) {
                assertTrue(e.getMessage().contains("Cannot transition from final state"),
                        "Expected exception for transition from final state");
            }
        } catch (IllegalStateException e) {
            fail("Unexpected IllegalStateException: " + e.getMessage());
        }

        System.out.println("[TEST] Finished testOrAndCombination");
    }


}
