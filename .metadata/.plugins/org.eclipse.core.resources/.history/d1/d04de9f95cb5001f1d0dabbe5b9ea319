package com.luis.tfg.security;

import org.junit.jupiter.api.Test;

import static org.junit.jupiter.api.Assertions.*;

import java.util.List;
import java.util.Map;

public class MethodOrderAgentTest {

    @Test
    public void testValidOrder() {
        TestClass instance = new TestClass("id1");
        ExecutionOrderRegistry.register(instance, "(start process end)");

        StateMachine sm = ExecutionOrderRegistry.getStateMachine(instance);
        assertNotNull(sm, "StateMachine should not be null");

        assertTrue(sm.validateTransition("start"), "Transition to 'start' should be valid");
        assertTrue(sm.validateTransition("process"), "Transition to 'process' should be valid");
        assertTrue(sm.validateTransition("end"), "Transition to 'end' should be valid");

        assertTrue(sm.isInFinalState(), "StateMachine should be in a final state");
    }

    @Test
    public void testNotEndingInFinalState() {
        System.out.println("[TEST] Starting testNotEndingInFinalState");

        TestClass instance = new TestClass("id2");
        ExecutionOrderRegistry.register(instance, "(start process end)");

        StateMachine sm = ExecutionOrderRegistry.getStateMachine(instance);
        assertNotNull(sm, "StateMachine should not be null");

        try {
            assertTrue(sm.validateTransition("start"));
            assertTrue(sm.validateTransition("process"));
            assertFalse(sm.isInFinalState(), "StateMachine should not be in a final state");
        } catch (IllegalStateException e) {
            fail("Unexpected IllegalStateException: " + e.getMessage());
        }

        System.out.println("[TEST] Finished testNotEndingInFinalState");
    }

    @Test
    public void testInvalidOrder() {
        System.out.println("[TEST] Starting testInvalidOrder");

        TestClass instance = new TestClass("id3");
        ExecutionOrderRegistry.register(instance, "(start process end)");

        StateMachine sm = ExecutionOrderRegistry.getStateMachine(instance);
        assertNotNull(sm, "StateMachine should not be null");

        try {
            sm.validateTransition("start");
            sm.validateTransition("end"); // Invalid transition
            fail("Expected an IllegalStateException due to invalid transition");
        } catch (IllegalStateException e) {
            assertTrue(e.getMessage().contains("Invalid transition from start to end"),
                    "Expected detailed invalid transition exception");
        }

        System.out.println("[TEST] Finished testInvalidOrder");
    }

    @Test
    public void testStateMachineNotFound() {
        System.out.println("[TEST] Starting testStateMachineNotFound");

        TestClass instance = new TestClass("id4");
        StateMachine sm = ExecutionOrderRegistry.getStateMachine(instance);
        assertNull(sm, "StateMachine should not be found for unregistered instance");

        System.out.println("[TEST] Finished testStateMachineNotFound");
    }

    @Test
    public void testFlexibleSequence() {
        System.out.println("[TEST] Starting testFlexibleSequence");

        TestClass instance = new TestClass("id5");
        ExecutionOrderRegistry.register(instance, "(start .* end)");

        StateMachine sm = ExecutionOrderRegistry.getStateMachine(instance);
        assertNotNull(sm, "StateMachine should not be null");

        try {
            assertTrue(sm.validateTransition("start"));
            assertTrue(sm.validateTransition("middle"));
            assertTrue(sm.validateTransition("end"));

            assertTrue(sm.isInFinalState(), "StateMachine should end in a final state");
        } catch (IllegalStateException e) {
            fail("Unexpected IllegalStateException: " + e.getMessage());
        }

        System.out.println("[TEST] Finished testFlexibleSequence");
    }

    @Test
    public void testAndCondition() {
        TestClass instance = new TestClass("id6");
        ExecutionOrderRegistry.register(instance, "(start & process) -> end");

        StateMachine sm = ExecutionOrderRegistry.getStateMachine(instance);
        assertNotNull(sm);

        assertTrue(sm.validateTransition("start"), "Transition to 'start' should be valid");
        assertTrue(sm.validateTransition("process"), "Transition to 'process' should be valid");
        assertTrue(sm.validateTransition("end"), "Transition to 'end' should be valid");

        assertTrue(sm.isInFinalState(), "StateMachine should be in a final state");
    }
    
    @Test
    public void testAndCondition2() {
        TestClass instance = new TestClass("id12");
        ExecutionOrderRegistry.register(instance, "(process & start) -> end");

        StateMachine sm = ExecutionOrderRegistry.getStateMachine(instance);
        assertNotNull(sm);

        assertTrue(sm.validateTransition("start"), "Transition to 'start' should be valid");
        assertTrue(sm.validateTransition("process"), "Transition to 'process' should be valid");
        assertTrue(sm.validateTransition("end"), "Transition to 'end' should be valid");

        assertTrue(sm.isInFinalState(), "StateMachine should be in a final state");
    }
    
//    @Test
//    public void testAndConditionNoExtraTransitions() {
//        TestClass instance = new TestClass("id17");
//        ExecutionOrderRegistry.register(instance, "(start & process) -> end");
//
//        StateMachine sm = ExecutionOrderRegistry.getStateMachine(instance);
//        assertNotNull(sm);
//
//        // Obtener transiciones
//        Map<String, List<String>> transitions = sm.getTransitions();
//
//        // Validar transiciones desde INITIAL
//        List<String> initialTransitions = transitions.get("INITIAL");
//        assertNotNull(initialTransitions);
//        assertEquals(2, initialTransitions.size(), "INITIAL should only transition to 'start' and 'process'");
//        assertTrue(initialTransitions.contains("start"), "INITIAL should transition to 'start'");
//        assertTrue(initialTransitions.contains("process"), "INITIAL should transition to 'process'");
//
//        // Validar transiciones de startA y startB
//        assertEquals(1, transitions.get("startA").size(), "startA should only transition to processB");
//        assertTrue(transitions.get("startA").contains("processB"), "startA should transition to processB");
//
//        assertEquals(1, transitions.get("startB").size(), "startB should only transition to processA");
//        assertTrue(transitions.get("startB").contains("processA"), "startB should transition to processA");
//
//        // Validar transiciones de processB y processA
//        assertEquals(1, transitions.get("processB").size(), "processB should only transition to end");
//        assertTrue(transitions.get("processB").contains("end"), "processB should transition to end");
//
//        assertEquals(1, transitions.get("processA").size(), "processA should only transition to end");
//        assertTrue(transitions.get("processA").contains("end"), "processA should transition to end");
//
//        // Validar que no hay transiciones adicionales
//        assertTrue(sm.validateTransition("start"), "Transition to 'start' should be valid");
//        assertTrue(sm.validateTransition("process"), "Transition to 'process' should be valid");
//        assertTrue(sm.validateTransition("end"), "Transition to 'end' should be valid");
//
//        assertTrue(sm.isInFinalState(), "StateMachine should be in a final state");
//    }


    @Test
    public void testOrCondition() {
        System.out.println("[TEST] Starting testOrCondition");

        TestClass instance = new TestClass("id7");
        ExecutionOrderRegistry.register(instance, "(start | process) -> end");

        StateMachine sm = ExecutionOrderRegistry.getStateMachine(instance);
        assertNotNull(sm, "StateMachine should not be null");

        try {
            assertTrue(sm.validateTransition("process"));
            assertTrue(sm.validateTransition("end"));

            assertTrue(sm.isInFinalState(), "StateMachine should end in a final state");
        } catch (IllegalStateException e) {
            fail("Unexpected IllegalStateException: " + e.getMessage());
        }

        System.out.println("[TEST] Finished testOrCondition");
    }
    
    @Test
    public void testOrCondition2() {
        System.out.println("[TEST] Starting testOrCondition");

        TestClass instance = new TestClass("id72");
        ExecutionOrderRegistry.register(instance, "(process | start) -> end");

        StateMachine sm = ExecutionOrderRegistry.getStateMachine(instance);
        assertNotNull(sm, "StateMachine should not be null");

        try {
            assertTrue(sm.validateTransition("process"));
            assertTrue(sm.validateTransition("end"));

            assertTrue(sm.isInFinalState(), "StateMachine should end in a final state");
        } catch (IllegalStateException e) {
            fail("Unexpected IllegalStateException: " + e.getMessage());
        }

        System.out.println("[TEST] Finished testOrCondition");
    }

    @Test
    public void testRepetition() {
        TestClass instance = new TestClass("id8");
        ExecutionOrderRegistry.register(instance, "(repeat){2} -> end");

        StateMachine sm = ExecutionOrderRegistry.getStateMachine(instance);
        assertNotNull(sm);

        assertTrue(sm.validateTransition("repeat"), "First repeat should be valid");
        assertTrue(sm.validateTransition("repeat"), "Second repeat should be valid");
        assertTrue(sm.validateTransition("end"), "Transition to end should be valid");

        assertTrue(sm.isInFinalState(), "StateMachine should be in a final state");
    }

    @Test
    public void testInvalidFlexibleSequence() {
        System.out.println("[TEST] Starting testInvalidFlexibleSequence");

        TestClass instance = new TestClass("id9");
        ExecutionOrderRegistry.register(instance, "(start .* end)");

        StateMachine sm = ExecutionOrderRegistry.getStateMachine(instance);
        assertNotNull(sm, "StateMachine should not be null");

        try {
            sm.validateTransition("start");
            sm.validateTransition("unrelated");
            sm.validateTransition("invalid");
            fail("Expected an IllegalStateException due to invalid transition");
        } catch (IllegalStateException e) {
            assertTrue(e.getMessage().contains("Invalid transition"), 
                    "Expected detailed invalid transition exception");
        }

        System.out.println("[TEST] Finished testInvalidFlexibleSequence");
    }

    @Test
    public void testInvalidRepetition() {
        System.out.println("[TEST] Starting testInvalidRepetition");

        TestClass instance = new TestClass("id10");
        ExecutionOrderRegistry.register(instance, "(repeat){2} -> end");

        StateMachine sm = ExecutionOrderRegistry.getStateMachine(instance);
        assertNotNull(sm, "StateMachine should not be null");

        try {
            sm.validateTransition("repeat");
            sm.validateTransition("end");
            fail("Expected an IllegalStateException due to invalid transition");
        } catch (IllegalStateException e) {
            assertTrue(e.getMessage().contains("Invalid transition"),
                    "Expected detailed invalid transition exception");
        }

        System.out.println("[TEST] Finished testInvalidRepetition");
    }
    
    @Test
    public void testGetTransitions() {
        System.out.println("[TEST] Starting testGetTransitions");

        TestClass instance = new TestClass("id21");
        ExecutionOrderRegistry.register(instance, "(start process end -> FINAL)");

        StateMachine sm = ExecutionOrderRegistry.getStateMachine(instance);
        assertNotNull(sm, "StateMachine should not be null");

        Map<String, List<String>> transitions = sm.getTransitions();
        
        // Verificar que hay 4 estados con transiciones ahora (INITIAL incluido)
        assertEquals(4, transitions.size(), "StateMachine should have 4 states with transitions (including INITIAL)");

        // Validar que INITIAL tiene transición a "start"
        assertTrue(transitions.containsKey("INITIAL"), "StateMachine should contain INITIAL state");
        assertTrue(transitions.get("INITIAL").contains("start"), "INITIAL state should transition to start");

        // Validar las transiciones del flujo principal
        assertTrue(transitions.containsKey("start"), "StateMachine should contain start state");
        assertTrue(transitions.get("start").contains("process"), "start state should transition to process");

        assertTrue(transitions.containsKey("process"), "StateMachine should contain process state");
        assertTrue(transitions.get("process").contains("end"), "process state should transition to end");

        assertTrue(transitions.containsKey("end"), "StateMachine should contain end state");
        assertTrue(transitions.get("end").contains("FINAL"), "end state should transition to FINAL");

        System.out.println("[TEST] Finished testGetTransitions");
    }
    
    @Test
    public void testNoRedundantTransitionsFromInitial() {
        TestClass instance = new TestClass("id22");
        ExecutionOrderRegistry.register(instance, "(start process end)");

        StateMachine sm = ExecutionOrderRegistry.getStateMachine(instance);
        assertNotNull(sm, "StateMachine should not be null");

        List<String> initialTransitions = sm.getTransitions().get("INITIAL");
        assertNotNull(initialTransitions, "Transitions from INITIAL should not be null");
        assertEquals(1, initialTransitions.size(), "INITIAL should only transition to 'start'");
        assertTrue(initialTransitions.contains("start"), "INITIAL should transition only to 'start'");
    }
    
    @Test
    public void testInvalidRepeatedTransition() {
        TestClass instance = new TestClass("id23");
        ExecutionOrderRegistry.register(instance, "(start process end)");

        StateMachine sm = ExecutionOrderRegistry.getStateMachine(instance);
        assertNotNull(sm, "StateMachine should not be null");

        try {
            sm.validateTransition("start");
            sm.validateTransition("start"); // Repeated transition
            fail("Expected an IllegalStateException due to repeated transition");
        } catch (IllegalStateException e) {
            assertTrue(e.getMessage().contains("Invalid transition"), 
                "Expected an invalid transition exception for repeated state");
        }
    }
    
    @Test
    public void testMultipleOrTransitions() {
        TestClass instance = new TestClass("id24");
        ExecutionOrderRegistry.register(instance, "(start | process) -> end -> FINAL");

        StateMachine sm = ExecutionOrderRegistry.getStateMachine(instance);
        assertNotNull(sm, "StateMachine should not be null");

        sm.validateTransition("start");
        sm.validateTransition("end");

        try {
            sm.validateTransition("start");
            fail("Expected IllegalStateException for transition from final state");
        } catch (IllegalStateException e) {
            assertTrue(e.getMessage().contains("Cannot transition from final state"),
                    "Expected exception for transition from final state");
        }
    }

    
    @Test
    public void testAndOrCombination() {
        TestClass instance = new TestClass("id55");
        ExecutionOrderRegistry.register(instance, "((start & process) | middle) -> end -> FINAL");

        StateMachine sm = ExecutionOrderRegistry.getStateMachine(instance);
        assertNotNull(sm, "StateMachine should not be null");

        // Prueba la rama del operador AND
        assertTrue(sm.validateTransition("start"), "Transition to 'start' should be valid");
        assertTrue(sm.validateTransition("process"), "Transition to 'process' should be valid");
        assertTrue(sm.validateTransition("end"), "Transition to 'end' should be valid");

        sm.validateTransition("middle");
        assertTrue(sm.validateTransition("end"), "Transition to 'end' should be valid");
    }
    
    @Test
    public void testNoTransitionsFromFinalState() {
        TestClass instance = new TestClass("id26");
        ExecutionOrderRegistry.register(instance, "(start process end) -> FINAL");

        StateMachine sm = ExecutionOrderRegistry.getStateMachine(instance);
        assertNotNull(sm, "StateMachine should not be null");

        sm.validateTransition("start");
        sm.validateTransition("process");
        sm.validateTransition("end");

        assertTrue(sm.isInFinalState(), "StateMachine should be in a final state");

        try {
            sm.validateTransition("process");
            fail("Expected an IllegalStateException for transition from final state");
        } catch (IllegalStateException e) {
            assertTrue(e.getMessage().contains("Cannot transition from final state"),
                "Expected exception for transition from final state");
        }
    }

    
    @Test
    public void testWildcardTransitions() {
        TestClass instance = new TestClass("id27");
        ExecutionOrderRegistry.register(instance, "(start .* end)");

        StateMachine sm = ExecutionOrderRegistry.getStateMachine(instance);
        assertNotNull(sm, "StateMachine should not be null");

        assertTrue(sm.validateTransition("start"), "Transition to 'start' should be valid");
        assertTrue(sm.validateTransition("intermediate1"), "Wildcard transition should be valid");
        assertTrue(sm.validateTransition("intermediate2"), "Wildcard transition should be valid");
        assertTrue(sm.validateTransition("end"), "Transition to 'end' should be valid");

        assertTrue(sm.isInFinalState(), "StateMachine should end in a final state");
    }
    
    @Test
    public void testMultipleStateMachines() {
        TestClass instance1 = new TestClass("id28");
        TestClass instance2 = new TestClass("id29");

        ExecutionOrderRegistry.register(instance1, "(start process end)");
        ExecutionOrderRegistry.register(instance2, "(init action done)");

        StateMachine sm1 = ExecutionOrderRegistry.getStateMachine(instance1);
        StateMachine sm2 = ExecutionOrderRegistry.getStateMachine(instance2);

        assertNotNull(sm1, "StateMachine for instance1 should not be null");
        assertNotNull(sm2, "StateMachine for instance2 should not be null");

        // Verificar transiciones en sm1
        assertTrue(sm1.validateTransition("start"));
        assertTrue(sm1.validateTransition("process"));
        assertTrue(sm1.validateTransition("end"));
        assertTrue(sm1.isInFinalState(), "StateMachine for instance1 should end in a final state");

        // Verificar transiciones en sm2
        assertTrue(sm2.validateTransition("init"));
        assertTrue(sm2.validateTransition("action"));
        assertTrue(sm2.validateTransition("done"));
        assertTrue(sm2.isInFinalState(), "StateMachine for instance2 should end in a final state");
    }

}
